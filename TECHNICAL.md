BADGR RSVP Reader – Technical DocumentationVersion: 1.0.0 (Production)Maintained By: BADGR Technologies LLC Workflow Engineering Team1. Architecture OverviewThe ReaderRSVP application is built on a modern reactive stack, utilizing Jetpack Compose for the UI layer and Kotlin Coroutines for high-precision timing logic. The architecture follows a strict separation of concerns via the MVVM pattern.Core ComponentsComponentResponsibilityMainActivity.ktEntry point; hosts the Jetpack Compose UI and manages the lifecycle of the RSVPEngine.RSVPReaderScreenHigh-level Composable containing the Word Display, Progress telemetry, and Control interfaces.RSVPEngine.ktThe "Brain." Handles text tokenization, ORP calculation, timing loops, and state management.2. Data Flow & Execution LogicThe system utilizes a unidirectional data flow to ensure UI consistency and predictable playback performance.Ingestion: Text is passed to RSVPEngine.loadText().Tokenization: String is split via whitespace into a sanitized word array.Initialization: The currentIndex is set to 0, and StateFlow emits the first word.Playback: A Coroutine-based Timing Loop executes:Calculates ORP Index for the current word.Constructs an AnnotatedString with the red fixation highlight.Suspends via delay(60,000ms / WPM).Increments index and triggers UI recomposition.3. ORP (Optimal Recognition Point) AlgorithmThe ORP is the specific fixation point in a word where the human eye recognizes the entire word fastest. By highlighting this point in BADGR Red, saccadic eye movement is eliminated, allowing for speeds up to 900 WPM.Algorithm LogicKotlinfun calculateOrpIndex(word: String): Int {
    return when (word.length) {
        in 1..2   -> 0      // "it" → "it"
        in 3..5   -> 1      // "word" → "wOrd"
        in 6..9   -> 2      // "reading" → "reAding"
        in 10..13 -> 3      // "understanding" → "undErstanding"
        else      -> 4      // "extraordinarily" → "extrAordinarily"
    }
}
Visual ImplementationTo ensure maximum readability, the ORP letter is rendered with a distinct SpanStyle:Color: #FF0000 (BADGR Red)Weight: FontWeight.BoldAlignment: Fixed horizontal coordinate (X) to prevent eye jitter.4. Timing Engine MechanicsPrecision timing is critical at high speeds. At 900 WPM, each word is displayed for only 67 milliseconds.WPMDelayWords Per Second200300ms3.33300200ms5.00450133ms7.50600100ms10.0090067ms15.00The Coroutine Advantage: Unlike Thread.sleep(), Kotlin Coroutines provide non-blocking suspension, ensuring the Android UI thread remains responsive for user input (Pause/Reset) even during high-frequency updates.5. UI/UX HierarchyThe interface is optimized for focus, utilizing the BADGR Technologies professional color palette.ElementHex CodePurposeBADGR Blue#0000FFPrimary Branding & AccentsBADGR White#FFFFFFPrimary Text & ContentBADGR Black#000000Background (OLED/High Contrast)BADGR Red#FF0000ORP Fixation Highlight6. State Management (Reactive Pattern)The engine leverages StateFlow to provide a lifecycle-aware stream of data to the UI.Encapsulation: The engine maintains a MutableStateFlow (private) while exposing a read-only StateFlow to the UI.Lifecycle: The UI "collects" the state as a Compose State object, ensuring that the app only consumes resources when it is in the foreground.7. Performance & SecurityOptimization StatusZero-Dependency: No external library bloat (minimized attack surface).O(n) Tokenization: Text is processed once during load; word lookups are O(1).60 FPS Target: UI updates are optimized to avoid unnecessary recomposition of static elements (logos/titles).Security ModelLocal-First: No network permissions requested; text data remains on-device.Sandboxed: Operates within the standard Android security sandbox with no external file access (v1.0).8. Build ConfigurationRequirementSpecificationMin SDK24 (Android 7.0)Target SDK34 (Android 14)LanguageKotlin 1.9.0JDKJava 17© 2026 BADGR Technologies LLC. All rights reserved. Built with modern Android best practices.
